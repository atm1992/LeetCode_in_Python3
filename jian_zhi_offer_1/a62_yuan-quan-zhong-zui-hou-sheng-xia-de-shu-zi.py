# -*- coding: UTF-8 -*-
"""
title: 圆圈中最后剩下的数字
0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。
例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。


示例 1：
输入: n = 5, m = 3
输出: 3

示例 2：
输入: n = 10, m = 17
输出: 2


限制：
1 <= n <= 10^5
1 <= m <= 10^6

解题思路：约瑟夫环。圆圈长度为n的解可看作长度为n-1的解加上报数的长度m。因为是圆圈，所以最后要对n取余。
找数学规律：
第一步，n个人的编号为：0、1、2、……、n-2、n-1。最后剩下的数字记为f(n,m)
第二步，删除编号m-1，若m-1小于n，则为m-1，否则为(m-1)%n。令k = (m-1)%n，则n-1个人的编号为：0、1、……、k-1、k+1、……、n-1
第三步，开始报数的编号变为了k+1，即 k+1、……、n-1、0、1、……、k-1。最后剩下的数字记为f'(n-1,m)，因为最后剩下的是一个确定值(虽然未知)，所以f'(n-1,m)=f(n,m)
第四步，将 k+1、……、n-1、0、1、……、k-1 映射为 0~n-2，即：
k+1、k+2、……、n-1、0、1、……、k-1
0、1、……、n-1-(k+1)、n-k-1、n-k、……、n-2
上一行编号映射为下一行编号的公式为：p(x) = (x-k-1)%n
下一行编号映射为上一行编号的公式为：p'(x) = (x+k+1)%n
第五步，由于n-1个人的编号使用p(x)映射后，变成了0、1、……、n-1-(k+1)、n-k-1、n-k、……、n-2，这与0、1、2、……、n-2、n-1具有相同的形式(都从0开始升序)，
因此最后剩下的数字此时可记为f(n-1,m)。由上可知，对于长度为n-1的序列中最后剩下的数字而言，映射前记为f'(n-1,m)；映射后记为f(n-1,m)。
代入映射规则，f'(n-1,m) = p'(f(n-1,m)) = (f(n-1,m)+k+1)%n，然后代入k = (m-1)%n 、f'(n-1,m) = f(n,m)，
得到递推公式：f(n,m) = f'(n-1,m) = (f(n-1,m) + m) % n

对于函数f(n,m)的说明：      # 固定m为一个确定值
对于长度为n的序列，编号为：0、1、2、……、n-2、n-1，该序列最后剩下的数字为f(n,m)
对于长度为n-1的序列，编号为：0、1、2、……、n-2，该序列最后剩下的数字为f(n-1,m)
……
对于长度为2的序列，编号为：0、1，该序列最后剩下的数字为f(2,m)
对于长度为1的序列，编号为：0，该序列最后剩下的数字为f(1,m)，即 f(1,m)只能等于0
"""


class Solution:
    def lastRemaining(self, n: int, m: int) -> int:
        """使用循环来模拟游戏规则。超时，通过 29/36 个测试用例"""
        ids = list(range(n))
        start = 0
        # 退出循环时，n == 1，表示数组ids中只剩一个元素
        while n > 1:
            k = (start + m - 1) % n
            ids.pop(k)
            # 因为pop出去了一个元素，所以元素的总个数要减1
            n -= 1
            # 注意：新的start是k，而不是k+1，因为原来的k被pop出去了，所以原来的k+1就到了位置k
            start = k
        return ids[0]

    def lastRemaining_2(self, n: int, m: int) -> int:
        """使用数学递推公式：f(n,m) = (f(n-1,m) + m) % n ，f(1,m) = 0"""
        # 初始值为n==1时的结果f(1,m) = 0
        res = 0
        # 从2遍历到n
        for i in range(2, n + 1):
            res = (res + m) % i
        return res


if __name__ == '__main__':
    print(Solution().lastRemaining(n=10, m=17))
