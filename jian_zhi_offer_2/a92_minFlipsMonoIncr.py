# -*- coding: UTF-8 -*-
"""
title: 翻转字符
如果一个由 '0' 和 '1' 组成的字符串，是以一些 '0'（可能没有 '0'）后面跟着一些 '1'（也可能没有 '1'）的形式组成的，那么该字符串是 单调递增 的。
我们给出一个由字符 '0' 和 '1' 组成的字符串 s，我们可以将任何 '0' 翻转为 '1' 或者将 '1' 翻转为 '0'。
返回使 s 单调递增 的最小翻转次数。


示例 1：
输入：s = "00110"
输出：1
解释：我们翻转最后一位得到 00111.

示例 2：
输入：s = "010110"
输出：2
解释：我们翻转得到 011111，或者是 000111。

示例 3：
输入：s = "00011000"
输出：2
解释：我们翻转得到 00000000。


提示：
1 <= s.length <= 20000
s 中只包含字符 '0' 和 '1'
"""


class Solution:
    def minFlipsMonoIncr(self, s: str) -> int:
        """
        动态规划
        dp[i] 表示使字符串s中前i个字符单调递增的最小翻转次数。
        dp[i][0] 表示将字符i翻转为0的情况下，前i个字符单调递增的最小翻转次数
        dp[i][1] 表示将字符i翻转为1的情况下，前i个字符单调递增的最小翻转次数
        将字符i翻转为0，若需保持单调递增，则字符i-1只能是0，即 dp[i][0]只能从dp[i-1][0]转移而来，dp[i][0] = dp[i-1][0] + int(s[i]=='1')；
        将字符i翻转为1，若需保持单调递增，则字符i-1既可以是0、也可以是1，即 dp[i][1]可以从dp[i-1][0] 或 dp[i-1][1]转移而来，
        dp[i][1] = min(dp[i-1][0], dp[i-1][1]) + int(s[i]=='0')
        """
        # 1 <= s.length
        dp_0, dp_1 = int(s[0] == '1'), int(s[0] == '0')
        for ch in s[1:]:
            dp_0, dp_1 = dp_0 + int(ch == '1'), min(dp_0, dp_1) + int(ch == '0')
        return min(dp_0, dp_1)


if __name__ == '__main__':
    print(Solution().minFlipsMonoIncr("010110"))
